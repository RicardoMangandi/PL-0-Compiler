//The parser file begins
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "compiler.h"

//functions used throughout
char *errorMessage(int errorNumber);
void emit(int opcode, char op[], int l, int m);

//global counters
int counter = 0;
int symbolIndex = 0; //counter when looping through symbol table as well
int codeIndex = 0;
int jumpOnCommandIndex = 0;

//new global variable declared
//int procedureCount = 0;
int numberOfProcedure = 0;
int procedureCountInSymbolTable = 0;

int findProcedure(int indexOfProcedureCounterInLoop, symbol *symbolTable, input *tokenList, char *nameOfProcedure); //ALL GOOD
void mark(int currentCount, symbol *symbolTable, input *tokenList);                                                 //NEED TO LOOK AT
int symbolTableCheck(char *nameOfString, int lexLevel, symbol *symbolTable);                                        // ALL GOOD
int symbolTableSearch(char *nameOfString, int lexLevel, symbol *symbolTable, int kind);                             //NEED TO LOOK AT

void block(int lexLevel, int paramter, int procedureIndex, symbol *symbolTable, input *tokenList); //NEED TO LOOK AT

int constDeclarationFunction(int lexLevel, symbol *symbolTable, input *tokenList);              //NEED TO LOOK AT
int varDeclarationFunction(int lexLevel, int parameter, symbol *symbolTable, input *tokenList); //ALL GOOD
int procedureDeclarationFunction(int lexLevel, symbol *symbolTable, input *tokenList);          //NEED TO LOOK AT

void isStatement(int lexLevel, symbol *symbolTable, input *tokenList);
void isExpression(int lexLevel, symbol *symbolTable, input *tokenList); //ALL GOOD
void isCondition(int lexLevel, symbol *symbolTable, input *tokenList);  //ALL GOOD
void isTerm(int lexLevel, symbol *symbolTable, input *tokenList);       //ALL GOOD
void isFactor(int lexLevel, symbol *symbolTable, input *tokenList);

instruction *code;

instruction *parse(input *tokenList, int print)
{


    //memory allocation
    code = malloc(500 * sizeof(instruction));
    symbol *symbolTable = malloc(500 * sizeof(symbol));
    printf("\n\n");

    //initialized the struct array to -9999 values
    for (int i = 0; i < 500; i++)
    {

        symbolTable[i].kind = -9999;
        strcpy(symbolTable[i].name, "-9999");
        symbolTable[i].val = -9999;
        symbolTable[i].level = -9999;
        symbolTable[i].address = -9999;
        symbolTable[i].mark = -9999;
        symbolTable[i].parameter = -9999;
    }

    //PROGRAM
    numberOfProcedure = 1; //number of procedure = 1 because "main" is a procedure that is declared
    emit(9, "JMP", 0, 0);  //default values setting it up where we will jump for now it is at 0

    for (int i = 0; i < tokenList[0].sizeOfList; i++)
    {

        if (tokenList[i].tokenType == procsym)
        {
            numberOfProcedure++;
            emit(9, "JMP", 0, numberOfProcedure); // setting it up to where we will jump for now it is at 0
        }
    }


    symbolTable[symbolIndex].kind = 3;
    strcpy(symbolTable[symbolIndex].name, "main");
    symbolTable[symbolIndex].val = 0;
    symbolTable[symbolIndex].level = 0;
    symbolTable[symbolIndex].address = 0;
    symbolTable[symbolIndex].mark = 0;
    symbolTable[symbolIndex].parameter = 0;
    procedureCountInSymbolTable++; //the first row is filled out in the symbol table
    symbolIndex++;

    //BLOCK:
    //lexLevel is currently 0
    //parameter is currently 0, not passing in any parameters
    //procedureIndex is currently 0, so main is located in procedureIndex 0
    block(0, 0, 0, symbolTable, tokenList); // GOOD

    if (tokenList[counter].tokenType != periodsym)
    { //Error : program must end with period

        printf("\n%s\n", errorMessage(1));
        exit(0);
    }



    //TEST CASE 1 WE ARE LOOPING TO VALUE 2
    //Need the value 2 here numberOfProcedure needs to be 2
    //printf("The recursive call worked? %d\n", numberOfProcedure);

    //never get here
    for (int i = 0; i < 2; i++)
    {


        printf("\n%d %s %d\n", i, symbolTable[i].name, symbolTable[i].kind);

        //potential issue later on

        int tempIndex = findProcedure(i, symbolTable, tokenList, symbolTable[i].name);
        printf("tempIndex is: %d\n", tempIndex);
        code[i].m = symbolTable[tempIndex].address; //expecting findProcedure to be index = 0 and index = 1
    }

    //printf("The symbolTable.address = %d\n", symbolTable[0].address);

    code[0].m = symbolTable[0].address;
    code[1].m = symbolTable[1].address;




   // printf("The recursive call worked? %d\n", codeIndex);
    for (int i = 0; i < codeIndex; i++)
    {



        if (code[i].opcode == 5)

        {
            int tempIndex = findProcedure(i, symbolTable, tokenList,symbolTable[i].name );

            code[i].m = symbolTable[1].address;
        }
    }

    //emit HALT
    emit(9, "SYS", 0, 3);

    if (print == 1)
    {
        printf("\nGenerated Assembly:\n");
        printf("Line    OP   L     M\n");

        for (int i = 0; i < codeIndex; i++)
            printf("%3d %6s %3d %5d \n", i, code[i].op, code[i].lexiLevel, code[i].m);

        return code;
    }

    else
        return code;
}

//linear search through the symbol table looking at the kind = 3 returns the index that matches value
int findProcedure(int indexOfProcedureCounterInLoop, symbol *symbolTable, input *tokenList, char *nameOfProcedure)
{
        printf("%d name: %s \n",indexOfProcedureCounterInLoop, nameOfProcedure);

        if (strcmp(symbolTable[indexOfProcedureCounterInLoop].name, nameOfProcedure) == 0)
            return indexOfProcedureCounterInLoop;

        else
            return -1;
}

//there could be a memory leak that causes this to fail
//goes through all the values that are not mark
void mark(int currentCount, symbol *symbolTable, input *tokenList)
{

    //printf("The symbol index is at: %d\n", symbolIndex);
    //value for symbol index is 3 PERFECT for test 1

    int i = symbolIndex - 1;
    while (currentCount >= 0 && i >= 0)
    {

        if (symbolTable[i].mark == 0)
        {
            symbolTable[i].mark = 1;
            currentCount--;
            i--;
        }

        else
        {
            i--;
        }
    }


}

//there could be a memory leak that causes this to fail
//if we access passed the size of the symbol table
//we call this function to ensure that we are not redeclaring
//var, proecedure, and constant names
//we also check if there has been code generated for it already
int symbolTableCheck(char *nameOfString, int lexLevel, symbol *symbolTable)
{
    for (int i = 0; i < 500; i++)
    {
        if (strcmp(nameOfString, symbolTable[i].name) == 0 && symbolTable[i].level == lexLevel && symbolTable[i].mark == 0)
        {
            return i;
        }
    }
    return -1;
}

//linear search through symbol table looking at name and level
//return index of exact match of name and kind, unmarked with nearest lexlevel
int symbolTableSearch(char *nameOfString, int lexLevel, symbol *symbolTable, int kind)
{
    int index = -1;

    for (int i = 0; i < symbolIndex; i++)
    {

        if (strcmp(nameOfString, symbolTable[i].name) == 0 && symbolTable[i].kind == kind && symbolTable[i].mark == 0)
        {

            if (index == -1)
            {

                index = i;

                continue;


            }

            if (abs(lexLevel - symbolTable[index].level) > abs(lexLevel - symbolTable[i].level))
            {
                index = i;
            }
        }
    }
    return index;
}

void block(int lexLevel, int paramter, int procedureIndex, symbol *symbolTable, input *tokenList)
{
    int c = 0;
    int v = 0;
    int p = 0;



    c = constDeclarationFunction(lexLevel, symbolTable, tokenList);

    v = varDeclarationFunction(lexLevel, paramter, symbolTable, tokenList);

    p = procedureDeclarationFunction(lexLevel, symbolTable, tokenList);

    symbolTable[procedureIndex].address = codeIndex;

    emit(6, "INC", 0, 4 + v);

    isStatement(lexLevel, symbolTable, tokenList);

    mark(c + v + p, symbolTable, tokenList);
}

//function will place all code inside struct array
void emit(int opcode, char op[], int l, int m)
{
    code[codeIndex].opcode = opcode;
    strcpy(code[codeIndex].op, op);
    code[codeIndex].lexiLevel = l;
    code[codeIndex].m = m;
    codeIndex++;
}

int constDeclarationFunction(int lexLevel, symbol *symbolTable, input *tokenList)
{

    int numberOfConst = 0;
    char savesIdentifier[50];

    if (tokenList[counter].tokenType == constsym)
    {

        do
        {

            numberOfConst++;
            counter++;
            if (tokenList[counter].tokenType != identsym)
            {

                //Error : const,var,procedure,call, and read keywords must be followed by identifier

                printf("\n%s\n", errorMessage(2));
                exit(0);
            }

            if (symbolTableCheck(tokenList[counter].str, lexLevel, symbolTable))
            {

                printf("\n%s\n", errorMessage(6));
                exit(0);
            }

            strcpy(savesIdentifier, tokenList[counter].str);
            counter++;

            if (tokenList[counter].tokenType != eqsym)
            {
                //Error : constants must be assigned with =

                printf("\n%s\n", errorMessage(4));
                exit(0);
            }

            if (tokenList[counter].tokenType != numbersym)
            {
                //Error : constants must be assigned an integer value

                printf("\n%s\n", errorMessage(5));
                exit(0);
            }

            else
            {

                symbolTable[symbolIndex].kind = 1;
                strcpy(symbolTable[symbolIndex].name, savesIdentifier);
                symbolTable[symbolIndex].val = atoi(tokenList[counter].str);
                symbolTable[symbolIndex].level = lexLevel;
                symbolTable[symbolIndex].address = 0;
                symbolTable[symbolIndex].mark = 0;
                symbolTable[symbolIndex].parameter = 0;

                symbolIndex++;
                counter++;
            }

        } while (tokenList[counter].tokenType == commasym);

        if (tokenList[counter].tokenType != semicolonsym)
        {
            //Error : constant and variable declarations must be followed by a semicolon

            printf("\n%s\n", errorMessage(7));
            exit(0);
        }

        counter++;
    }

    return numberOfConst;
}

//ALL GOOOD
int varDeclarationFunction(int lexLevel, int parameter, symbol *symbolTable, input *tokenList)
{

    int numberVars = 0;

    if (parameter == 1)
    {
        numberVars = 1;
    }

    else
    {
        numberVars = 0;
    }

    if (tokenList[counter].tokenType == varsym)
    {

        do
        {

            numberVars++;
            counter++;

            if (tokenList[counter].tokenType != identsym)
            {
                //Error : const,var,procedure,call, and read keywords must be followed by identifier

                printf("\n%s\n", errorMessage(2));
                exit(0);
            }

            //check if the var is already declared in symbol table
            if (symbolTableCheck(tokenList[counter].str, lexLevel, symbolTable) != -1)
            {
                //Error : undeclared variable or constant in equation
                //incorrect error, error should be already declared in symbol table with same name

                printf("\n%s\n", errorMessage(6));
                exit(0);
            }

            //IF THE ITEM WAS NOT FOUND THEN WE WILL INSERT THE VALUE INSIDE THE SYMBOL TABLE
            else
            {

                symbolTable[symbolIndex].kind = 2;
                strcpy(symbolTable[symbolIndex].name, tokenList[counter].str);
                symbolTable[symbolIndex].val = 0;
                symbolTable[symbolIndex].level = lexLevel;
                symbolTable[symbolIndex].address = numberVars + 3;
                symbolTable[symbolIndex].mark = 0;
                symbolTable[symbolIndex].parameter = 0;
                symbolIndex++;
                counter++;
            }

        } while (tokenList[counter].tokenType == commasym);

        if (tokenList[counter].tokenType != semicolonsym)
        {
            //Error : constant and variable declarations must be followed by a semicolon

            printf("\n%s\n", errorMessage(7));
            exit(0);
        }

        else
            counter++;
    }

    return numberVars;
}

int procedureDeclarationFunction(int lexLevel, symbol *symbolTable, input *tokenList)
{

    numberOfProcedure = 0;

    if (tokenList[counter].tokenType == procsym)
    {

        do
        {

            numberOfProcedure++;
            counter++;
            if (tokenList[counter].tokenType != identsym)
            {
                //Error : const,var,procedure,call, and read keywords must be followed by identifier

                printf("\n%s\n", errorMessage(2));
                exit(0);
            }

            if (symbolTableCheck(tokenList[counter].str, lexLevel, symbolTable) != -1)
            {

                //Error : undeclared variable or constant in equation
                //COULD BE WRONG, THIS COULD BE A DIFFERENT PROCEDURE ERROR
                //error is symbol already declared in the table correct when close to being done

                //Errpr : competing symbol declarations at the same level
                printf("\n%s\n", errorMessage(3));
                exit(0);
            }

            int procedureIndex = symbolIndex; // end of table

            symbolTable[symbolIndex].kind = 3;
            strcpy(symbolTable[symbolIndex].name, tokenList[counter].str);
            symbolTable[symbolIndex].val = procedureCountInSymbolTable;
            symbolTable[symbolIndex].level = lexLevel;
            symbolTable[symbolIndex].address = 0;
            symbolTable[symbolIndex].mark = 0;
            symbolTable[symbolIndex].parameter = 0;
            procedureCountInSymbolTable++;
            symbolIndex++;
            counter++;

            if (tokenList[counter].tokenType == lparentsym)
            {
                counter++;
                if (tokenList[counter].tokenType != identsym)
                {

                    //Error : parameter may only be specified by an identifier

                    printf("\n%s\n", errorMessage(17));
                    exit(0);
                }

                symbolTable[symbolIndex].kind = 2;
                strcpy(symbolTable[symbolIndex].name, tokenList[counter].str);
                symbolTable[symbolIndex].val = 0;
                symbolTable[symbolIndex].level = lexLevel + 1;
                symbolTable[symbolIndex].address = 3;
                symbolTable[symbolIndex].mark = 0;
                symbolTable[symbolIndex].parameter = 0;
                symbolIndex++;

                //value is currently 1 for procedureIndex
                symbolTable[procedureIndex].parameter = 1;

                counter++;

                if (tokenList[counter].tokenType != rparentsym)
                {

                    //Error : right parenthesis must follow left parenthesis

                    printf("\n%s\n", errorMessage(14));
                    exit(0);
                }

                counter++;

                if (tokenList[counter].tokenType != semicolonsym)
                {
                    //Error : constant and variable declarations must be followed by a semicolon
                    //maybe wrong with error type

                    printf("\n%s\n", errorMessage(7));
                    exit(0);
                }

                counter++;

                block(lexLevel + 1, 1, procedureIndex, symbolTable, tokenList);
            }

            else
            {

                if (tokenList[counter].tokenType != semicolonsym)
                {

                    //7"Error : symbol declarations must be followed by a semicolon"
                    printf("\n%s\n", errorMessage(7));
                    exit(0);
                }

                counter++;
                //printf("\n%s\n", tokenList[counter].str);
                block(lexLevel + 1, 0, procedureIndex, symbolTable, tokenList);
            }

            if (code[codeIndex - 1].opcode != 2 && code[codeIndex - 1].m != 0)
            {

                emit(1, "LIT", 0, 0);
                emit(0, "RTN", 0, 0);
            }

            if (tokenList[counter].tokenType != semicolonsym)
            {

                //Error : symbol declarations must be followed by a semicolon

                printf("\n%s\n", errorMessage(7));
                exit(0);
            }

            counter++;

        } while (tokenList[counter].tokenType == procsym);
    }

    return numberOfProcedure;
}

void isStatement(int lexLevel, symbol *symbolTable, input *tokenList)
{

    if (tokenList[counter].tokenType == identsym)
    {

        //printf("The lexLevel of being searched is %d\n", lexLevel);
        int symbolIndexReturned = symbolTableSearch(tokenList[counter].str, lexLevel, symbolTable, 2);
        // printf("\nHopefull we returned the value of 2? Value %d\n", symbolIndexReturned);

        if (symbolIndexReturned == -1)
        {

            //not sure what error this is
            //current error
            //could be error 3

            printf("\n%s\n", errorMessage(3));
            exit(0);
        }

        counter++;

        if (tokenList[counter].tokenType != becomessym)
        {
            //Error : assignment statements must use :=

            printf("\n%s\n", errorMessage(9));
            exit(0);
        }

        counter++;

        isExpression(lexLevel, symbolTable, tokenList);

        emit(4, "STO", lexLevel - symbolTable[symbolIndex - 1].level, symbolTable[symbolIndex - 1].address);

        return;
    }

    if (tokenList[counter].tokenType == callsym)
    {

        //printf("\nMAKES IT INSIDE CALLYSM\n");

        // printf("\nsymbolIndex Name: %s symbolIndex level: %d\n", tokenList[counter].str, lexLevel + 1);

        counter++;
        //
        if (tokenList[counter].tokenType != identsym)
        {

            //const,var,procedure,call, and read keywords must be followed by identifier

            printf("\n%s\n", errorMessage(2));
            exit(0);
        }
        //printf("\nsymbolIndex level: %d symbolIndex marked: %d\n", symbolTable[symbolIndex - 1].level, symbolTable[symbolIndex - 1].mark);
        symbolTable[1].mark = 0;
        int tempsymbolIndex = symbolTableSearch(tokenList[counter].str, lexLevel, symbolTable, 3);

        //printf("\nLexlevel is %d\n", lexLevel);
        //printf("\nThe current values being checked are: tokenList[counter].str = %s, lexLevel = %d \n", tokenList[counter].str, lexLevel);
        //int tempsymbolIndex = symbolTableCheck(tokenList[counter].str, lexLevel + 1, symbolTable);

        //printf("\nCurrent name of call: %s current level: %d  \n", tokenList[counter].str, lexLevel);

        /*
        printf("SymbolTable index 1 name: %s\n", symbolTable[1].name);
        printf("SymbolTable index 1 kind: %d\n", symbolTable[1].kind);
        printf("SymbolTable index 1 val: %d\n", symbolTable[1].val);
        printf("SymbolTable index 1 level: %d\n", symbolTable[1].level);
        printf("SymbolTable index 1 address: %d\n", symbolTable[1].address);
        printf("SymbolTable index 1 mark: %d\n", symbolTable[1].mark);
        printf("SymbolTable index 1 param: %d\n", symbolTable[1].parameter);
        */
        if (tempsymbolIndex == -1)
        {
            //Error : undeclared procedure for call

            printf("\n%s\n", errorMessage(16));
            exit(0);
        }

        counter++;
        // printf("The next token is: %s\n", tokenList[counter].str);

        if (tokenList[counter].tokenType == lparentsym)
        {
            counter++;
            if (symbolTable[symbolIndex].parameter != 1)
            {
                //Error : parameter may only be specified by an identifier

                printf("\n%s\n", errorMessage(16));
                exit(0);
            }
            else
            {
                isExpression(lexLevel, symbolTable, tokenList);

                if (tokenList[counter].tokenType != rparentsym)
                {
                    //Error : right parenthesis must follow left parenthesis

                    printf("\n%s\n", errorMessage(14));
                    exit(0);
                }

                counter++;
            }
        }

        //if the next token is not a left parenthesis then do literal
        else
        {
            emit(1, "LIT", 0, 0);
        }

        //CAL is 5?
        emit(5, "CAL", 0, 2);

        //emit(5, "CAL", lexLevel - symbolTable[symbolIndex - 1].level, symbolTable[symbolIndex - 1].val);

        return;
    }

    if (tokenList[counter].tokenType == returnsym)
    {

        if (lexLevel == 0)
        {

            //Error : competing symbol declarations at the same level 3
            //OR
            //Error : cannot return from main 19

            printf("\n%s\n", errorMessage(19));
            exit(0);
        }

        counter++;

        if (tokenList[counter].tokenType == lparentsym)
        {

            counter++;
            isExpression(lexLevel, symbolTable, tokenList);
            //would need to double check the emit variables
            emit(0, "RTN", 0, 0);

            if (tokenList[counter].tokenType != rparentsym)
            {

                //Error : right parenthesis must follow left parenthesis

                printf("\n%s\n", errorMessage(14));
                exit(0);
            }

            else
            {
                counter++;
                emit(1, "LIT", 0, 0);
                emit(0, "RTN", 0, 0);
            }
        }

        return;
    }

    if (tokenList[counter].tokenType == beginsym)
    {

        do
        {

            counter++;
            isStatement(lexLevel, symbolTable, tokenList);

        } while (tokenList[counter].tokenType == semicolonsym);

        if (tokenList[counter].tokenType != endsym)
        {
            //Error : begin must be followed by end

            printf("\n%s\n", errorMessage(10));
            exit(0);
        }

        counter++;

        //printf("Current counter is %d and token number: %d = 18", counter, tokenList[counter].tokenType);

        //printf("Eventually will return to main with %d\n", tokenList[counter].tokenType);

        return;
    }

    if (tokenList[counter].tokenType == ifsym)
    {

        counter++;
        isCondition(lexLevel, symbolTable, tokenList);

        jumpOnCommandIndex = codeIndex;
        emit(8, "JPC", 0, jumpOnCommandIndex);

        if (tokenList[counter].tokenType != thensym)
        {
            //Error : if must be followed by then

            printf("\n%s\n", errorMessage(11));
            exit(0);
        }

        counter++;

        isStatement(lexLevel, symbolTable, tokenList);

        if (tokenList[counter].tokenType == elsesym)
        {

            counter++;

            int jumpIndex = codeIndex;
            emit(9, "JMP", 0, jumpIndex);

            code[jumpOnCommandIndex].m = codeIndex;
            isStatement(lexLevel, symbolTable, tokenList);
            code[jumpIndex].m = codeIndex;
        }

        else
        {

            code[jumpOnCommandIndex].m = codeIndex;
        }

        return;
    }

    if (tokenList[counter].tokenType == whilesym)
    {

        counter++;
        int loopindex = codeIndex;
        isCondition(lexLevel, symbolTable, tokenList);

        if (tokenList[counter].tokenType != dosym)
        {

            //Error : while must be followed by do

            printf("\n%s\n", errorMessage(12));
            exit(0);
        }

        counter++;

        jumpOnCommandIndex = codeIndex;

        emit(8, "JPC", 0, jumpOnCommandIndex);

        isStatement(lexLevel, symbolTable, tokenList);
        //ensure of what the lexiLevel should be passed as
        emit(9, "JMP", 0, loopindex);

        code[jumpOnCommandIndex].m = codeIndex;

        return;
    }

    if (tokenList[counter].tokenType == readsym)
    {

        counter++;
        if (tokenList[counter].tokenType != identsym)
        {

            //Error : const,var,procedure,call, and read keywords must be followed by identifier

            printf("\n%s\n", errorMessage(2));
            exit(0);
        }

        //symIdx = SYMBOLTABLESEARCH (token, lexlevel, kind 2)
        symbolIndex = symbolTableSearch(tokenList[counter].str, lexLevel, symbolTable, 2);

        if (symbolIndex == -1)
        {

            //Error : undeclared variable or constant in equation

            printf("\n%s\n", errorMessage(6));
            exit(0);
        }

        counter++;
        emit(9, "SYS", 0, 2);

        emit(4, "STO", lexLevel - symbolTable[symbolIndex].level, symbolTable[symbolIndex].address);

        return;
    }

    if (tokenList[counter].tokenType == writesym)
    {

        counter++;

        isExpression(lexLevel, symbolTable, tokenList);
        emit(9, "SYS", 0, 1);
        return;
    }
}

//GOOD
void isCondition(int lexLevel, symbol *symbolTable, input *tokenList)
{

    if (tokenList[counter].tokenType == oddsym)
    {

        counter++;
        isExpression(lexLevel, symbolTable, tokenList);
        emit(2, "OPR", 0, 6);
    }

    else
    {

        isExpression(lexLevel, symbolTable, tokenList);

        if (tokenList[counter].tokenType == eqsym)
        {

            counter++;
            isExpression(lexLevel, symbolTable, tokenList);
            emit(2, "OPR", 0, 8);
        }

        else if (tokenList[counter].tokenType == neqsym)
        {

            counter++;
            isExpression(lexLevel, symbolTable, tokenList);
            emit(2, "OPR", 0, 9);
        }

        else if (tokenList[counter].tokenType == lessym)
        {

            counter++;
            isExpression(lexLevel, symbolTable, tokenList);
            emit(2, "OPR", 0, 10);
        }

        else if (tokenList[counter].tokenType == leqsym)
        {
            counter++;

            isExpression(lexLevel, symbolTable, tokenList);
            emit(2, "OPR", 0, 11);
        }

        else if (tokenList[counter].tokenType == gtrsym)
        {

            counter++;
            isExpression(lexLevel, symbolTable, tokenList);
            emit(2, "OPR", 0, 12);
        }

        else if (tokenList[counter].tokenType == geqsym)
        {

            counter++;
            isExpression(lexLevel, symbolTable, tokenList);
            emit(2, "OPR", 0, 13);
        }

        else
        {

            //Error : condtion must contain comparsion operator

            printf("\n%s\n", errorMessage(13));
            exit(0);
        }
    }
}

//GOOD
void isExpression(int lexLevel, symbol *symbolTable, input *tokenList)
{

    if (tokenList[counter].tokenType == minussym)
    {

        counter++;
        isTerm(lexLevel, symbolTable, tokenList);
        emit(2, "OPR", 0, 1);

        while (tokenList[counter].tokenType == plussym ||
               tokenList[counter].tokenType == minussym)
        {

            if (tokenList[counter].tokenType == plussym)
            {

                counter++;
                isTerm(lexLevel, symbolTable, tokenList);
                emit(2, "OPR", 0, 2);
            }

            else
            {

                counter++;
                isTerm(lexLevel, symbolTable, tokenList);
                emit(2, "OPR", 0, 3);
            }
        }
    }

    else
    {

        if (tokenList[counter].tokenType == plussym)
        {
            counter++;
        }

        isTerm(lexLevel, symbolTable, tokenList);
        while (tokenList[counter].tokenType == plussym ||
               tokenList[counter].tokenType == minussym)
        {

            if (tokenList[counter].tokenType == plussym)
            {

                counter++;
                isTerm(lexLevel, symbolTable, tokenList);
                emit(2, "OPR", 0, 2); //ADD
            }

            else
            {

                counter++;
                isTerm(lexLevel, symbolTable, tokenList);
                emit(2, "OPR", 0, 3); //SUB
            }
        }
    }
}

//GOOD
void isTerm(int lexLevel, symbol *symbolTable, input *tokenList)
{

    isFactor(lexLevel, symbolTable, tokenList);

    while (tokenList[counter].tokenType == multsym ||
           tokenList[counter].tokenType == slashsym ||
           tokenList[counter].tokenType == modsym)
    {

        if (tokenList[counter].tokenType == multsym)
        {
            counter++;
            isFactor(lexLevel, symbolTable, tokenList);
            emit(2, "OPR", 0, 4);
        }

        else if (tokenList[counter].tokenType == slashsym)
        {

            counter++;
            isFactor(lexLevel, symbolTable, tokenList);
            emit(2, "OPR", 0, 5);
        }

        else
        {

            counter++;
            isFactor(lexLevel, symbolTable, tokenList);
            emit(2, "OPR", 0, 6);
        }
    }
}

void isFactor(int lexLevel, symbol *symbolTable, input *tokenList)
{

    if (tokenList[counter].tokenType == identsym)
    {

        int symbolIndexV = symbolTableSearch(tokenList[counter].str, lexLevel, symbolTable, 2);

        int symbolIndexC = symbolTableSearch(tokenList[counter].str, lexLevel, symbolTable, 3);

        if (symbolIndexV == -1 || symbolIndexC == -1)
        {
            //Error : undeclared variable or constant in equation"

            printf("\n%s %d\n", errorMessage(6), counter);
            exit(0);
        }

        else if (symbolIndexC == -1 || (symbolIndexV != -1 && symbolTable[symbolIndexV].level > symbolTable[symbolIndexC].level))
        {

            emit(3, "LOD", lexLevel - symbolTable[symbolIndexV].level, symbolTable[symbolIndexV].address);
        }

        else
        {

            emit(1, "LIT", 0, symbolTable[symbolIndexC].val);
        }
    }

    else if (tokenList[counter].tokenType == numbersym)
    {

        emit(3, "LIT", 0, atoi(tokenList[counter].str));
        counter++;
        return;
    }

    else if (tokenList[counter].tokenType == lparentsym)
    {

        counter++;
        isExpression(lexLevel, symbolTable, tokenList);
        if (tokenList[counter].tokenType != rparentsym)
        {
            //Error : right parenthesis must be followed by left parenthesis

            printf("\n%s\n", errorMessage(14));
            exit(0);
        }

        counter++;
    }

    else if (tokenList[counter].tokenType == callsym)
    {

        isStatement(lexLevel, symbolTable, tokenList);
        return;
    }

    else
    {
        //Error : arithmetic equations must contain operands, parentheses, numbers, or symbols

        printf("\n%s\n", errorMessage(15));
        exit(0);
    }
}

//function will return a char array which holds an error

char *errorMessage(int errorNumber)
{

    char *errorStrings[] = {
        "index zero",
        "Error : program must end with period",
        "Error : const,var,procedure,call, and read keywords must be followed by identifier",
        "Error : competing symbol declarations at the same level",
        "Error : constants must be assigned with =",
        "Error : constants must be assigned an integer value",
        "Error : undeclared variable or constant in equation",
        "Error : symbol declarations must be followed by a semicolon",
        "Error : only variable values may be altered",
        "Error : assignment statements must use :=",
        "Error : begin must be followed by end",
        "Error : if must be followed by then",
        "Error : while must be followed by do",
        "Error : condition must contain comparison operator",
        "Error : right parenthesis must follow left parenthesis",
        "Error : arithmetic equations must contain operands, parentheses, numbers, or symbols",
        "Error : undeclared procedure for call",
        "Error : parameter may only be specified by an identifier",
        "Error : parameter must be declared",
        "Error : cannot return from main"

    };

    return errorStrings[errorNumber];
}
